using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Twitch.Base.Models.NewAPI.Webhooks;

namespace Twitch.Base.Services.NewAPI
{
    /// <summary>
    /// The APIs for Webhook-based services.
    /// </summary>
    public class WebhooksService : NewTwitchAPIServiceBase
    {

        /// <summary>
        /// Creates an instance of the WebhooksService
        /// </summary>
        /// <param name="connection"></param>
        public WebhooksService(TwitchConnection connection) : base(connection) { }

        /// <summary>
        /// Gets the Webhook subscriptions of a user identified by a Bearer token, in order of expiration.  Requires App Token.
        /// </summary>
        /// <returns></returns>
        public async Task<IEnumerable<WebhookSubscriptionModel>> GetWebhookSubscriptions(int maxResults=100)
        {
            if (maxResults < 10)
                maxResults = 10;
            if (maxResults > 100)
                maxResults = 100;
            return await this.GetPagedDataResultAsync<WebhookSubscriptionModel>("webhooks/subscriptions", maxResults);
        }

        /// <summary>
        /// Subscribe to a webhook topic
        /// </summary>
        /// <param name="callback">URL where notifications will be delivered.</param>
        /// <param name="topic">URL for the topic to subscribe to or unsubscribe from. topic maps to a new Twitch API endpoint.</param>
        /// <param name="lease_seconds">Number of seconds until the subscription expires. Default: 0. Maximum: 864000.</param>
        /// <param name="secret">Secret used to sign notification payloads. The X-Hub-Signature header is generated by sha256(secret, notification_bytes).</param>
        /// <returns></returns>
        public async Task<bool> SubscribeWebhookTopic(string callback, string topic, int lease_seconds, string secret)
        {
            return await processWebhookTopicRequest(callback,"subscribe",topic, lease_seconds, secret);
        }

        /// <summary>
        /// Unsubscribe from a webhook topic
        /// </summary>
        /// <param name="callback">URL where notifications will be delivered.</param>
        /// <param name="topic">URL for the topic to subscribe to or unsubscribe from. topic maps to a new Twitch API endpoint.</param>
        /// <param name="secret">Secret used to sign notification payloads. The X-Hub-Signature header is generated by sha256(secret, notification_bytes).</param>
        /// <returns></returns>
        public async Task<bool> UnSubscribeWebhookTopic(string callback, string topic, string secret)
        {
            return await processWebhookTopicRequest(callback, "unsubscribe", topic, 0, secret);

        }

        /// <summary>
        /// Processes the webhook topic request
        /// </summary>
        /// <param name="callback">URL where notifications will be delivered.</param>
        /// <param name="mode"></param>
        /// <param name="topic">URL for the topic to subscribe to or unsubscribe from. topic maps to a new Twitch API endpoint.</param>
        /// <param name="lease_seconds">Number of seconds until the subscription expires. Default: 0. Maximum: 864000.</param>
        /// <param name="secret">Secret used to sign notification payloads. The X-Hub-Signature header is generated by sha256(secret, notification_bytes).</param>
        /// <returns></returns>
        private async Task<bool> processWebhookTopicRequest(string callback, string mode, string topic, int lease_seconds, string secret)
        {
            var postObject = new StringContent("{\"hub.callback\":\"" + callback + "\", \"hub.mode\":\"" + mode + "\", \"hub.topic\":\""+ topic + "\", \"hub.lease_seconds\":" + lease_seconds.ToString() + ", \"hub.secret\":\""+ secret + "\"}",Encoding.UTF8, "application/json");

            try
            {
                var response = await this.PostAsync("webhooks/hub", postObject);
                
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }
}
